package com.kga.springauthorizationserver.model;

import lombok.*;
import org.hibernate.Hibernate;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.Id;
import javax.persistence.Table;
import java.time.Instant;
import java.util.Objects;

/**Объект(Сущность) авторизации. Сущность, которая используется для сохранения информации, отображаемой из OAuth2Authorization объекта домена.*/

@Getter
@Setter
@ToString
@RequiredArgsConstructor
@Entity
public class Authorization {
    /**Идентификатор, который однозначно идентифицирует OAuth2Authorization*/
    @Id
    @Column
    private String id;
    /**Идентификатор, который однозначно идентифицирует RegisteredClient.*/
    private String registeredClientId;
    /**Основное имя владельца ресурса (или клиента).*/
    private String principalName;
    /**Используемый тип авторизации.*/
    private String authorizationGrantType;
    /**Дополнительные атрибуты, специфичные для выполненного типа предоставления авторизации – например,
     * аутентифицированный Principal, OAuth2AuthorizationRequest, авторизованная область (области)(scope) и другие.*/
    @Column(length = 4000)
    private String attributes;
    /**Состояние*/
    @Column(length = 500)
    private String state;

    /*Блок параметров кода авторизации*/
    /**https://www.rfc-editor.org/rfc/rfc6749#section-1.3.1
     * Код авторизации
     *
     *    Код авторизации получается с помощью сервера авторизации
     *    как посредник между клиентом и владельцем ресурса. Вместо
     *    запрос авторизации непосредственно у владельца ресурса, клиента
     *    направляет владельца ресурса на сервер авторизации (через его
     *    пользовательский агент, как определено в [ RFC2616 ]), который, в свою очередь, направляет
     *    владелец ресурса обратно клиенту с кодом авторизации.
     *
     *    Прежде чем направить владельца ресурса обратно к клиенту с
     *    код авторизации, сервер авторизации аутентифицирует
     *    владельцем ресурса и получает авторизацию. Потому что владелец ресурса
     *    аутентифицируется только на сервере авторизации, ресурс
     *    учетные данные владельца никогда не передаются клиенту.
     *
     *    Код авторизации обеспечивает несколько важных преимуществ безопасности,
     *    такие как возможность аутентификации клиента, а также
     *    передача токена доступа напрямую клиенту без
     *    передавая его через пользовательский агент владельца ресурса и, возможно,
     *    раскрытие его другим, в том числе владельцу ресурса.*/
    @Column(length = 4000)
    private String authorizationCodeValue;
    /**Код авторизации выданный на */
    private Instant authorizationCodeIssuedAt;
    /**Срок Действия Кода авторизации Истекает В*/
    private Instant authorizationCodeExpiresAt;
    /**https://datatracker.ietf.org/doc/html/rfc8414
     * Метаданные, это информация необходимая для взаимодействия с Сервером авторизации OAuth 2.0,
     * включая расположение его конечных точек и возможности сервера авторизации. */
    private String authorizationCodeMetadata;

    /*Блок параметров токена доступа*/
    /**https://datatracker.ietf.org/doc/html/rfc6749#section-1.4
     * Токен доступа
     *
     * Токены доступа - это учетные данные, используемые для доступа к защищенным ресурсам.
     * Токены доступа - это строка, представляющая авторизацию, выданную
     * клиенту. Строка обычно непрозрачна для клиента. Токены
     * представляют конкретные области и продолжительность доступа, предоставленные владельцем
     * ресурса и принудительно применяемые сервером ресурсов и авторизацией
     * сервер.
     *
     * Токены может обозначать идентификатор, используемый для получения
     * информации авторизации, или может самостоятельно содержать информацию авторизации в
     * проверяемый способ (т.е. строка токена, состоящая из некоторых данных и
     * подписи). Дополнительные учетные данные для аутентификации, которые выходят за
     * рамки данной спецификации, могут потребоваться для того, чтобы
     * клиент мог использовать токен.
     *
     * Токен доступа обеспечивает уровень абстракции, заменяющий различные
     * конструкции авторизации (например, имя пользователя и пароль) с помощью одного
     * токен, понятный серверу ресурсов. Эта абстракция позволяет
     * выдача токенов доступа, более ограничительных, чем предоставление авторизации
     * используется для их получения, а также избавляет сервер ресурсов от необходимости
     * разбираться в широком спектре методов аутентификации.
     *
     * Токены доступа могут иметь различные форматы, структуры и методы
     * использования (например, криптографические свойства) в зависимости от ресурса
     * требования к безопасности сервера. Атрибуты маркера доступа и
     * методы, используемые для доступа к защищенным ресурсам, выходят за рамки
     * данной спецификации и определяются сопутствующими спецификациями, такими
     * как [RFC6750].*/
    @Column(length = 4000)
    private String accessTokenValue;
    /**Токен выдан в/на*/
    private Instant accessTokenIssuedAt;
    /**Токен истекает в */
    private Instant accessTokenExpiresAt;
    /**Метаданные токена
     * @see Authorization#authorizationCodeMetadata*/
    @Column(length = 2000)
    private String accessTokenMetadata;
    /**https://datatracker.ietf.org/doc/html/rfc6749#section-7.1
     * Типы токенов доступа
     *  Тип токена доступа предоставляет клиенту информацию, необходимую для успешного использования маркера доступа
     для выполнения запроса защищенного ресурса (наряду с атрибутами, специфичными для типа). Клиент НЕ ДОЛЖЕН
     использовать токен доступа, если он не понимает тип токена.
     Например, используется тип токена "на предъявителя", определенный в [RFC6750]
     просто включив строку маркера доступа в запрос:

     GET /resource/1 HTTP/1.1
     Host: example.com
     Authorization: Bearer mF_9.B5f-4.1JqM

     в то время как тип токена "mac", определенный в [OAuth-HTTP-MAC], используется путем выдачи ключа кода
     аутентификации сообщения (MAC) вместе с токеном доступа, который используется для подписи определенных
     компонентов HTTP запросы:

     GET /resource/1 HTTP/1.1
     Ведущий: example.com
     Авторизация: MAC id="h480djs93hd8",
     nonce="274312:dj83hs9s",
     mac="kDZvddkndxvhGRXZhvuDjEWhGeE="

     Приведенные выше примеры приведены только в целях иллюстрации. Разработчикам рекомендуется ознакомиться со
     спецификациями [RFC6750] и [OAuth-HTTP-MAC] перед использованием.

     Каждое определение типа токена доступа определяет дополнительные атрибуты (если таковые имеются), отправляемые
     клиенту вместе с параметром ответа "access_token". Он также определяет метод аутентификации HTTP, используемый
     для включения маркера доступа при выполнении запроса защищенного ресурса.
     */
    private String accessTokenType;
    /**https://datatracker.ietf.org/doc/html/rfc6749#section-3.3
     * Область действия маркера доступа
     *
     * Конечные точки авторизации и токена позволяют клиенту указывать область запроса доступа,
     * используя параметр запроса "область". В свою очередь, сервер авторизации использует параметр ответа
     * "область действия" для информирования клиента о области действия выданного токена доступа.
     *
     * Значение параметра scope выражается в виде списка строк с учетом регистра, разделенных пробелами.
     * Строки определяются сервером авторизации. Если значение содержит несколько строк, разделенных пробелами,
     * их порядок не имеет значения, и каждая строка добавляет дополнительный диапазон доступа к запрашиваемой области.
     *
     *   scope = scope-token *( SP scope-token )
     *   scope-token = 1*( %x21 / %x23-5B / %x5D-7E )
     *
     * Сервер авторизации МОЖЕТ полностью или частично игнорировать область, запрошенную клиентом,
     * на основе политики сервера авторизации или инструкций владельца ресурса. Если область действия выданного
     * маркера доступа отличается от области, запрошенной клиентом, сервер авторизации ДОЛЖЕН включить параметр
     * ответа "область действия", чтобы сообщить клиенту о фактической предоставленной области действия.
     *
     * Если клиент опускает параметр scope при запросе авторизация, сервер авторизации ДОЛЖЕН либо обработать запрос,
     * используя заранее определенное значение по умолчанию, либо выполнить запрос с ошибкой, указав недопустимую
     * область действия. Сервер авторизации ДОЛЖЕН задокументировать свои требования к области действия и значение
     * по умолчанию (если оно определено).
     * */
    @Column(length = 1000)
    private String accessTokenScopes;

    /*Блок параметров токена обновления*/
    /**https://datatracker.ietf.org/doc/html/rfc6749#section-6
     * 6. Обновление токена доступа
     *
     * Если сервер авторизации выдал клиенту токен обновления, клиент делает запрос на обновление к конечной точке
     * токена, добавив следующие параметры, используя формат "application/x-www-form-urlencoded" согласно приложению
     * B с кодировкой символов UTF-8 в теле сущности HTTP-запроса:
     *
     * grant_type
     * требуемый. Значение ДОЛЖНО быть установлено в "refresh_token".
     *
     * refresh_token
     * требуемый. Токен обновления, выданный клиенту.
     *
     * scope
     * необязательный. Область запроса доступа, как описано в разделе 3.3. Запрашиваемая область НЕ ДОЛЖНА включать
     * в себя какую-либо область, первоначально не предоставленную владельцем ресурса, и, если она опущена,
     * рассматривается как равная области, первоначально предоставленной владельцем ресурса.
     *
     * Поскольку токены обновления обычно являются долговременными учетными данными, используемыми для запроса
     * дополнительных токенов доступа, токен обновления привязан к клиенту, которому он был выдан. Если тип клиента
     * является конфиденциальным или клиенту были выданы учетные данные клиента (или назначены другие требования
     * к аутентификации), клиент ДОЛЖЕН пройти аутентификацию с помощью сервера авторизации, как описано в разделе 3.2.1.
     *
     * Например, клиент выполняет следующий HTTP-запрос, используя безопасность транспортного уровня (с дополнительными
     * разрывами строк только для целей отображения):
     *
     *  POST /token HTTP/1.1
     *      Host: server.example.com
     *      Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
     *      Content-Type: application/x-www-form-urlencoded
     *
     *      grant_type=refresh_token&refresh_token=tGzv3JOkF0XG5Qx2TlKWIA
     *
     * Сервер авторизации ДОЛЖЕН:
     * - требовать проверки подлинности клиента для конфиденциальных клиентов или для любого клиента, которому были
     * выданы учетные данные клиента (или с другими требованиями к проверке подлинности),
     * - аутентифицировать клиента, если включена проверка подлинности клиента, и убедиться, что маркер обновления
     * был выдан аутентифицированному клиенту, и
     * - проверить маркер обновления.
     *
     * Если запрос действителен и авторизован, сервер авторизации выдает токен доступа, как описано в разделе 5.1.
     * Если запрос не прошел проверку или является недействительным, сервер авторизации возвращает ответ об ошибке,
     * как описано в разделе 5.2.
     *
     * Сервер авторизации МОЖЕТ выдать новый токен обновления, и в этом случае клиент ДОЛЖЕН отказаться от старого
     * токена обновления и заменить его новым токеном обновления. Сервер авторизации МОЖЕТ отозвать старый токен о
     * бновления после выдачи клиенту нового токена обновления. Если выдается новый токен обновления, область действия
     * токена обновления ДОЛЖНА быть идентична области действия токена обновления, включенного клиентом в запрос.
     *
     * https://datatracker.ietf.org/doc/html/rfc6749#section-10.4
     * Серверы авторизации МОГУТ выдавать токены обновления клиентам веб-приложений и клиентам собственных приложений.
     *
     *    Токены обновления ДОЛЖНЫ храниться в тайне при передаче и хранении и использоваться совместно только сервером
     *    авторизации и клиентом, которому были выданы токены обновления.  Сервер авторизации ДОЛЖЕН поддерживать
     *    привязку между токеном обновления и клиентом, которому он был выдан.  Токены обновления ДОЛЖНЫ передаваться
     *    только с использованием TLS, как описано в разделе 1.6, с проверкой подлинности сервера, как определено [RFC2818].
     *
     *    Сервер авторизации ДОЛЖЕН проверять привязку между токеном обновления и идентификатором клиента всякий раз,
     *    когда идентификатор клиента может быть аутентифицирован.  Когда проверка подлинности клиента невозможна,
     *    сервер авторизации ДОЛЖЕН развернуть другие средства для обнаружения злоупотребления токеном обновления.
     *
     *    Например, сервер авторизации может использовать ротацию токенов обновления, при которой новый токен обновления
     *    выдается с каждым ответом на обновление токена доступа.  Предыдущий токен обновления становится
     *    недействительным, но сохраняется сервером авторизации.  Если токен обновления скомпрометирован и впоследствии
     *    используется как злоумышленником, так и законным клиентом, один из них представит недействительный
     *    токен обновления, который проинформирует сервер авторизации о нарушении.
     *
     *    Сервер авторизации ДОЛЖЕН гарантировать, что маркеры обновления не могут быть сгенерированы, изменены или
     *    угаданы для получения действительных маркеров обновления неавторизованными сторонами.*/
    @Column(length = 4000)
    private String refreshTokenValue;
    /**Токен выдан в/на*/
    private Instant refreshTokenIssuedAt;
    /**Токен истекает в */
    private Instant refreshTokenExpiresAt;
    /**Метаданные токена
     * @see Authorization#authorizationCodeMetadata*/
    @Column(length = 2000)
    private String refreshTokenMetadata;

    /*Блок параметров oidcId токена*/
    /**https://docs.spring.io/spring-security/site/docs/current-SNAPSHOT/api/org/springframework/security/oauth2/core/oidc/OidcIdToken.html
     * Реализация AbstractOAuth2Tokenпредставления токена идентификации OpenID Connect Core 1.0.
     * Это OidcIdTokenтокен безопасности, который содержит «утверждения» об аутентификации конечного пользователя сервером авторизации.
     * */
    @Column(length = 4000)
    private String oidcIdTokenValue;
    /** время, когда был выпущен ID Token(iat)*/
    private Instant oidcIdTokenIssuedAt;
    /**время истечения срока действия (exp), в которое или после которого Токен ID НЕ ДОЛЖЕН быть принят*/
    private Instant oidcIdTokenExpiresAt;
    /**Метаданные токена
     * @see Authorization#authorizationCodeMetadata*/
    @Column(length = 2000)
    private String oidcIdTokenMetadata;
    /**утверждения (claims) об аутентификации конечного пользователя*/
    @Column(length = 2000)
    private String oidcIdTokenClaims;


    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || Hibernate.getClass(this) != Hibernate.getClass(o)) return false;
        Authorization that = (Authorization) o;
        return id != null && Objects.equals(id, that.id);
    }

    @Override
    public int hashCode() {
        return getClass().hashCode();
    }
}


